% 清除命令窗口，并加载数据
tic; % 开始计时
clc; % 清除命令窗口
clear; % 清除所有变量
load sj.csv; % 加载数据文件，这里假设 sj.csv 包含100个目标点的坐标
x = sj(:, 1:2:8); % 提取奇数列作为 x 坐标
x = x(:); % 将矩阵转换为列向量
y = sj(:, 2:2:8); % 提取偶数列作为 y 坐标
y = y(:); % 将矩阵转换为列向量
sj = [x y]; % 将 x 和 y 合并为一个矩阵
d1 = [70, 40]; % 定义初始点的坐标
sj0 = [d1; sj; d1]; % 将初始点添加到目标点集合中
sj = sj0 * pi / 180; % 将角度转换为弧度

% 初始化距离矩阵 d
d = zeros(102); % 创建一个102x102的零矩阵

% 计算距离矩阵 d 中的元素
for i = 1:101
    for j = i + 1:102
        % 使用球面距离公式计算两点间的距离
        temp = cos(sj(i, 1) - sj(j, 1)) * cos(sj(i, 2)) * cos(sj(j, 2)) + sin(sj(i, 2)) * sin(sj(j, 2));
        d(i, j) = 6370 * acos(temp); % 地球半径约为6370公里
    end
end
d = d + d'; % 将矩阵对称化，因为距离是双向的

% 初始化参数
L = 102; % 点的总数
w = 50; % 父代个体数
dai = 100; % 迭代次数

% 通过改良圈算法选取优良父代 A
for k = 1:w
    c = randperm(100); % 随机生成100个整数的排列
    c1 = [1, c + 1, 102]; % 将随机排列的首尾连接起来
    flag = 1; % 初始化标志变量

    % 循环直到没有更优的路径
    while flag > 0
        flag = 0; % 重置标志变量
        for m = 1:L - 3
            for n = m + 2:L - 1
                % 如果交换两个点可以缩短路径，则进行交换
                if d(c1(m), c1(n)) + d(c1(m + 1), c1(n + 1)) < d(c1(m), c1(m + 1)) + d(c1(n), c1(n + 1))
                    flag = 1; % 发现更优路径，设置标志变量
                    c1(m + 1:n) = c1(n:-1:m + 1); % 交换点
                end
            end
        end
    end
    J(k, c1) = 1:102; % 将父代个体的路径保存到矩阵 J 中
end
J = J / 102; % 归一化路径，使其起点和终点为1
J(:, 1) = 0; J(:, 102) = 1; % 将起点和终点设置为0和1

% 初始化随机数生成器
rand('state', sum(clock));

% 遗传算法实现过程
A = J; % 父代初始化

% 进行 dai 次迭代
for k = 1:dai
    B = A; % 复制父代到子代 B
    c = randperm(w); % 随机生成 w 个整数的排列

    % 交配产生子代 B
    for i = 1:2:w
        F = 2 + floor(100 * rand(1)); % 随机选择一个切割点
        temp = B(c(i), F:102); % 切割子代 B 的路径
        B(c(i), F:102) = B(c(i + 1), F:102); % 交换两个子代的部分路径
        B(c(i + 1), F:102) = temp;
    end

    % 变异产生子代 C
    by = find(rand(1, w) < 0.1); % 随机选择变异点
    if length(by) == 0
        by = floor(w * rand(1)) + 1; % 如果没有变异点，则随机选择一个
    end
    C = A(by, :); % 复制变异点对应的父代个体到子代 C
    L3 = length(by); % 变异点的数量
    for j = 1:L3
        bw = 2 + floor(100 * rand(1, 3)); % 随机生成3个切割点
        bw = sort(bw); % 对切割点进行排序
        C(j, :) = C(j, [1:bw(1) - 1, bw(2) + 1:bw(3), bw(1):bw(2), bw(3) + 1:102]); % 变异路径
    end

    % 将父代、子代 B 和子代 C 合并为一个集合 G
    G = [A; B; C];
    TL = size(G, 1); % 集合 G 的大小

    % 在父代和子代中选择优良品种作为新的父代
    [dd, IX] = sort(G, 2); % 按列对 G 进行排序
    temp(1:TL) = 0; % 初始化临时变量
    for j = 1:TL
        for i = 1:101
            temp(j) = temp(j) + d(IX(j, i), IX(j, i + 1)); % 计算路径长度
        end
    end
    [DZ, IZ] = sort(temp); % 按路径长度对临时变量进行排序
    A = G(IZ(1:w), :); % 选择最短路径的个体作为新的父代

end

% 输出最优路径和长度
path = IX(IZ(1), :) % 最优路径
long = DZ(1) % 最优路径的长度

% 停止计时并输出运行时间
toc;

% 绘制最优路径
xx = sj0(path, 1); % 路径的 x 坐标
yy = sj0(path, 2); % 路径的 y 坐标
plot(xx, yy, '-o'); % 绘制路径图