% 计时开始
tic;

% 清除命令窗口并清除所有变量
clc; clear;

% 加载数据文件 sj.csv，该文件包含100个目标点的坐标数据
load sj.csv;

% 提取 sj 数据中的 x 坐标，使用步长为2，从第1列开始，直到第8列结束
x = sj(:, 1:2:8);
% 将 x 转换为列向量
x = x(:);

% 提取 sj 数据中的 y 坐标，使用步长为2，从第2列开始，直到第8列结束
y = sj(:, 2:2:8);
% 将 y 转换为列向量
y = y(:);

% 将 x 和 y 坐标合并成一个矩阵 sj
sj = [x y];

% 定义初始点的坐标 d1
d1 = [70, 40];

% 将初始点 d1 添加到 sj 矩阵的开始和末尾，并将所有角度转换为弧度
sj0 = [d1; sj; d1];
sj = sj0 * pi / 180;

% 初始化一个 102x102 的零矩阵，用于存储点之间的距离
d = zeros(102);

% 计算距离矩阵 d 中的元素，使用球面余弦定理计算两点之间的距离
for i = 1:101
    for j = i + 1:102
        temp = cos(sj(i, 1) - sj(j, 1)) * cos(sj(i, 2)) * cos(sj(j, 2)) + sin(sj(i, 2)) * sin(sj(j, 2));
        d(i, j) = 6370 * acos(temp); % 地球半径约为6370公里
    end
end

% 将距离矩阵 d 变成对称矩阵，因为距离是双向的
d = d + d';

% 初始化参数
L = 102; % 点的总数，包括初始点和目标点
w = 50; % 父代个体数
dai = 100; % 遗传算法的迭代次数

% 通过改良圈算法选取优良父代 A
for k = 1:w
    c = randperm(100); % 生成 1 到 100 的随机排列
    c1 = [1, c + 1, 102]; % 将随机排列的首尾连接起来，包括初始点和末尾点
    flag = 1; % 初始化标志变量

    % 循环直到没有更优的路径
    while flag > 0
        flag = 0; % 重置标志变量
        % 尝试交换路径中的点以找到更短的路径
        for m = 1:L - 3
            for n = m + 2:L - 1
                if d(c1(m), c1(n)) + d(c1(m + 1), c1(n + 1)) < d(c1(m), c1(m + 1)) + d(c1(n), c1(n + 1))
                    flag = 1; % 发现更优路径
                    c1(m + 1:n) = c1(n:-1:m + 1); % 交换点
                end
            end
        end
    end
    % 将父代个体的路径保存到矩阵 J 中
    J(k, c1) = 1:102;
end

% 归一化 J 矩阵，将路径的首尾设置为0和1
J = J / 102;
J(:, 1) = 0; J(:, 102) = 1;

% 设置随机数生成器的状态
rand('state', sum(clock));

% 初始化父代 A 为 J 矩阵
A = J;

% 遗传算法的迭代过程
for k = 1:dai
    B = A; % 创建子代 B 的副本

    % 交配产生子代 B
    for i = 1:2:w
        % 随机生成一个 0 到 1 之间的数列，用于选择交配点
        ch0 = rand; ch(1) = 4 * ch0 * (1 - ch0);
        for j = 2:50
            ch(j) = 4 * ch(j - 1) * (1 - ch(j - 1));
        end
        ch = 2 + floor(100 * ch); % 将数列映射到 2 到 100 之间
        % 交换子代 B 中的路径片段
        temp = B(i, ch);
        B(i, ch) = B(i + 1, ch);
        B(i + 1, ch) = temp;
    end

    % 变异产生子代 C
    by = find(rand(1, w) < 0.1); % 随机选择变异点
    if length(by) == 0
        by = floor(w * rand(1)) + 1; % 如果没有变异点，则随机选择一个
    end
    C = A(by, :); % 从父代 A 中选择变异个体
    L3 = length(by); % 变异个体的数量
    for j = 1:L3
        % 随机生成变异点
        bw = 2 + floor(100 * rand(1, 3));
        bw = sort(bw); % 对变异点进行排序
        % 变异路径
        C(j, :) = C(j, [1:bw(1) - 1, bw(2) + 1:bw(3), bw(1):bw(2), bw(3) + 1:102]);
    end

    % 将父代 A、子代 B 和子代 C 合并为一个集合 G
    G = [A; B; C];
    TL = size(G, 1); % 集合 G 的大小

    % 在父代和子代中选择优良品种作为新的父代
    [dd, IX] = sort(G, 2); % 按列对 G 进行排序
    temp(1:TL) = 0; % 初始化临时变量
    % 计算每个个体的路径长度
    for j = 1:TL
        for i = 1:101
            temp(j) = temp(j) + d(IX(j, i), IX(j, i + 1));
        end
    end
    [DZ, IZ] = sort(temp); % 按路径长度对临时变量进行排序
    % 选择最短路径的个体作为新的父代
    A = G(IZ(1:w), :);
end

% 输出最优路径和长度
path = IX(IZ(1), :) % 最优路径
long = DZ(1) % 最优路径的长度

% 计时结束
toc;

xx = sj0(path, 1); % 提取 x 坐标
yy = sj0(path, 2); % 提取 y 坐标
plot(xx, yy, '-o');